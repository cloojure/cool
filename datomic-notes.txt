
Questions
  What does the "added" field in [ Entity Attribute Value Tx Added ] tuple mean?

Notes:
  A "datom" is a tuple of 5 values: [ Entity Attribute Value Tx Added ]. However, the word datom is
  often used ambiguously to mean entity, attribute, or value. There is ample potential for
  confustion and the reader must exercise caution to use the correct terminology and keep these
  separate concepts clear.

  A 'added' field of a datom is often ignored and the other four items are abbrevieate as EAVT.

  A "fact" is the triple of [entity attribute value].  When a fact is asserted (inserted) to
  Datomic, the 'added' field has the value 'true'. When a fact is retracted (removed) from Datomic,
  the 'added' field has the value 'false'.  A change to the value of an attribute for an entity is
  modeled as a pair of facts, where the first fact retracts the old value (added=false) and the
  second fact inserts the new value (added=true).

  A simple "value" is something you can touch, like the number 5, the string "abc", or other literal
  data types (literal lists & maps of values included). Values are immutable. However, the "value"
  of an entity can be a pointer (EID, see below) to another entity.

  An "entity" is a collection of zero or more values. It is much like a map in Clojure or Java, with
  transactional semantics added on. Specifically,
  an entity is like a Clojure atom containing a pointer to an immutable Clojure map.  The map may
  contain zero, one, or many values.  At any point in time, the "value" of a Datomic entity is the
  immutable map of attribute/value pairs (aka key/value pairs) that it points to.  A transaction in
  Datomic mutates the entity/atom to point to a different immutable map (the new map is usually
  derived from the old map value by adding/replacing/removing attribute/value pairs). The work
  "entity" can also be used to mean the concrete implementation (which is lazy-loading) of the
  logical entity object.

  An "attribute" is like a key in a map object (it is also analogous to a fieldname in a record or
  class definition).  Each attribute is named (using a keyword) and this name is like a pointer from
  an entity to a value. The word "attribute" is a bit ambiguous in English (e.g. "He has many good
  attributes"), and it would be more precise to interprete the term "attribute" as "attribute-name"
  or just "key".

  The value of the :db/id attribute for an entity is the "entity id" or EID. This is like a pointer
  in C or Java and is used to access a particular entity (just like a pointer in Java is used to
  access a specific instance of a class).

  The "name" of an entity or attribute is the value of its :db/ident attribute. Please keep clear
  the difference between the :db/id (EID) and :db/ident ('name').

  Note that a user defines an attribute by inserting an entity for the new attribute into the
  Datomic "root partition" :db.part/db.  The value corresponging to the :db/ident key of the
  attribute definition (e.g.  :person/name) is the "name" of the attribute that is referenced in
  queries (e.g. [?eid :person/name ?cust-name]).

  An entity is a logical collection, like a map. It is accessed by its Entity ID or EID, which is a
  long integer and functions just like a pointer.

  In regular Clojure, one would use the terms "map, key, value" (each key-value pair is also
  referred to as a map entry).  In Datomic, one uses the terms "entity, attribute, value".  The
  correspond terms can nearly always be used interchangably, which can be a source of confusion.
  Also, keep in mind the the Datomic Entity object is actually implmented as a lazy-loading map-like
  structure, so displaying its value using (println ...) may not display attributes that haven't
  been loaded yet.  Use the (touch <entity>) function to force loading of all attributes (one can
  also use "(into {} <entity>)" syntax to construct a plain Clojure map from an entity object).

  Normally, each attribute in an entity will belong to the same namespace. This looks similar to
  familiar object/field notation:

      42                  ; EID (pointer) to entity a 'person' entity
        person/name       ; attribute of type 'person.name'
        person/address    ; attribute of type 'person.address'
        person/phone      ; attribute
        person/ssn        ; attribute

  This is just like the clojure code:

      ; a 'person' map literal
      {
        :person/name       "hobo"         
        :person/address    "park"         
        :person/phone      nil            
        :person/ssn        123-43-6789    
      }

  Note that a 'person' type is never defined (there is nothing analgous to a Person class
  definition). We only imagine that a 'person' type exists since it appears the data is intended
  to describ a person's details. This intented use is emphasized since the 'person' namespace is
  used for all the attributes of EID 42. However, this is only a convention, and is not enforced
  by Datomic. This is also legal:

      42                  ; entity
        ork/type          ; attribute
        weapon/type       ; attribute
        plant/leaf-type   ; attribute
        pantheon/source   ; attribute

  and the corresponding Clojure map:

      ; a map of unrelated entries
      {                                           
        :ork/type          :ork.type/uruk-hai
        :weapon/type       :weapon.type/sword
        :plant/leaf-type   plant.leaf-type/needle
        :pantheon/source   pantheon.source/greek   
      }

  In this case, what is entity 42? Is is an ork, a weapon, a plant, or a pantheon? This question
  cannot be answered out of context. An entity is just a mutable map, and the data it holds only
  makes sense when coupled with the logic of your application.

  The attribute values on an entity can, in turn, be other entities. The namespace of these
  sub-types is normally constructed from the parent namespace & attribute name, as in:

      ; the person.address 'type' (note the change of '/' -> '.' compared to person/address
      person.address/number
      person.address/street-name
      person.address/street-type
      person.address/unit-number
      person.address/city
      person.address/state
      person.address/zipcode

  Again, note that the 'person.address' type is never defined (there is nothing analogous to a
  'PersonAddress' class). Again, it is only convention of defining a namespace derived from the
  concatenation of the 'parent' namespace and the attribute name (its :db/ident value) that makes
  is "look like" we have an object-oriented class hierarchy. This pattern is not enforced by
  Datomic, which only sees a jumble of maps, where some map values point to other maps.

  As the "type system" does not have to be organized hierarchically (it does not even exist!), the
  pointers (e.g. attribute values) can be organized in any fashion. They could be hierarchical
  (like the location of goods in a warehouse) or they could be highly interconnected (like the
  graph of "likes" in a social application).

  An attribute that points to another entity (as opposed to a literal value like the string "abc")
  is like an arrow with both a tail and a head.  Imagine we have Sarah, Jane, and Rose, and a social
  graph with a :person/likes attribute so that Sarah likes Jane, and Jane likes Rose.  Draw this as:

      sarah --> jane --> rose

  An entity has access both to the "outbound" pointers as well as the "inbound" pointers.  The
  outbound pointers are accessed like the entries in a regular normal map:

      (:person/likes sarah)   ; => jane
      (:person/likes jane)    ; => rose
      (:person/likes rose)    ; => nil

  However, we can traverse the inbound pointers as well:

      (:person/_likes sarah)  ; => nil
      (:person/_likes jane)   ; => sarah
      (:person/_likes rose)   ; => jane

  Thus, these entities actually behave like these Clojure maps:

    ; sarah
    { :person/likes      jane
      :person/_likes     nil }

    ; jane
    { :person/likes      rose
      :person/_likes     sarah }

    ; rose
    { :person/likes      nil
      :person/_likes     jane }

  where both keys :person/likes and person/_likes are present.  Note that if either for forward or
  reverse attributes refers to more than a single entity, then a set of entities are returned
  instead of a single entity.


